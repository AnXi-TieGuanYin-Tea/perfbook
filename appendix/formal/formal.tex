% appendix/formal/formal.tex

\chapter{Formal Verification}
\label{app:formal:Formal Verification}

\QuickQuizChapter{app:formal:Formal Verification}

Parallel algorithms can be hard to write, and even harder to debug.
Testing, though essential, is insufficient, as fatal race conditions
can have extremely low probabilities of occurrence.
Proofs of correctness can be valuable, but in the end are just as
prone to human error as is the original algorithm.

It would be very helpful to have a tool that could somehow locate
all race conditions.
A number of such tools exist, for example,
the language Promela and its compiler Spin.

\input{appendix/formal/spinhint}
\input{appendix/formal/dyntickrcu}

\section{Summary}
\label{app:formal:Summary}

Promela is a very powerful tool for validating small parallel algorithms.
It is a useful tool in the parallel kernel hacker's toolbox, but
it should not be the only tool.
The QRCU experience is a case in point: given the Promela validation,
the proof of correctness, and several
rcutorture
% @@@ <A HREF="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;hb=HEAD;f=Documentation/RCU/torture.txt">rcutorture</A>
runs, I now feel
reasonably confident in the QRCU algorithm and its implementation.
But I would certainly not feel so confident given only one of the three!

Nevertheless, if your code is so complex that you find yourself
relying too heavily on validation
tools, you should carefully rethink your design.
For example, a complex implementation of the dynticks interface for
preemptable RCU turned out to
have a much simpler alternative implementation, as discussed in
Section~\ref{app:formal:Simplicity Avoids Formal Validation}.
All else being equal, a simpler implementation is much better than
a mechanical proof for a complex implementation!
