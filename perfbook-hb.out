\BOOKMARK [0][-]{chapter.1}{1 How To Use This Book}{}
\BOOKMARK [1][-]{section.1.1}{1.1 Roadmap}{chapter.1}
\BOOKMARK [1][-]{section.1.2}{1.2 Quick Quizzes}{chapter.1}
\BOOKMARK [1][-]{section.1.3}{1.3 Alternatives to This Book}{chapter.1}
\BOOKMARK [1][-]{section.1.4}{1.4 Sample Source Code}{chapter.1}
\BOOKMARK [1][-]{section.1.5}{1.5 Whose Book Is This?}{chapter.1}
\BOOKMARK [0][-]{chapter.2}{2 Introduction}{}
\BOOKMARK [1][-]{section.2.1}{2.1 Historic Parallel Programming Difficulties}{chapter.2}
\BOOKMARK [1][-]{section.2.2}{2.2 Parallel Programming Goals}{chapter.2}
\BOOKMARK [2][-]{subsection.2.2.1}{2.2.1 Performance}{section.2.2}
\BOOKMARK [2][-]{subsection.2.2.2}{2.2.2 Productivity}{section.2.2}
\BOOKMARK [2][-]{subsection.2.2.3}{2.2.3 Generality}{section.2.2}
\BOOKMARK [1][-]{section.2.3}{2.3 Alternatives to Parallel Programming}{chapter.2}
\BOOKMARK [2][-]{subsection.2.3.1}{2.3.1 Multiple Instances of a Sequential Application}{section.2.3}
\BOOKMARK [2][-]{subsection.2.3.2}{2.3.2 Use Existing Parallel Software}{section.2.3}
\BOOKMARK [2][-]{subsection.2.3.3}{2.3.3 Performance Optimization}{section.2.3}
\BOOKMARK [1][-]{section.2.4}{2.4 What Makes Parallel Programming Hard?}{chapter.2}
\BOOKMARK [2][-]{subsection.2.4.1}{2.4.1 Work Partitioning}{section.2.4}
\BOOKMARK [2][-]{subsection.2.4.2}{2.4.2 Parallel Access Control}{section.2.4}
\BOOKMARK [2][-]{subsection.2.4.3}{2.4.3 Resource Partitioning and Replication}{section.2.4}
\BOOKMARK [2][-]{subsection.2.4.4}{2.4.4 Interacting With Hardware}{section.2.4}
\BOOKMARK [2][-]{subsection.2.4.5}{2.4.5 Composite Capabilities}{section.2.4}
\BOOKMARK [2][-]{subsection.2.4.6}{2.4.6 How Do Languages and Environments Assist With These Tasks?}{section.2.4}
\BOOKMARK [1][-]{section.2.5}{2.5 Discussion}{chapter.2}
\BOOKMARK [0][-]{chapter.3}{3 Hardware and its Habits}{}
\BOOKMARK [1][-]{section.3.1}{3.1 Overview}{chapter.3}
\BOOKMARK [2][-]{subsection.3.1.1}{3.1.1 Pipelined CPUs}{section.3.1}
\BOOKMARK [2][-]{subsection.3.1.2}{3.1.2 Memory References}{section.3.1}
\BOOKMARK [2][-]{subsection.3.1.3}{3.1.3 Atomic Operations}{section.3.1}
\BOOKMARK [2][-]{subsection.3.1.4}{3.1.4 Memory Barriers}{section.3.1}
\BOOKMARK [2][-]{subsection.3.1.5}{3.1.5 Cache Misses}{section.3.1}
\BOOKMARK [2][-]{subsection.3.1.6}{3.1.6 I/O Operations}{section.3.1}
\BOOKMARK [1][-]{section.3.2}{3.2 Overheads}{chapter.3}
\BOOKMARK [2][-]{subsection.3.2.1}{3.2.1 Hardware System Architecture}{section.3.2}
\BOOKMARK [2][-]{subsection.3.2.2}{3.2.2 Costs of Operations}{section.3.2}
\BOOKMARK [1][-]{section.3.3}{3.3 Hardware Free Lunch?}{chapter.3}
\BOOKMARK [2][-]{subsection.3.3.1}{3.3.1 3D Integration}{section.3.3}
\BOOKMARK [2][-]{subsection.3.3.2}{3.3.2 Novel Materials and Processes}{section.3.3}
\BOOKMARK [2][-]{subsection.3.3.3}{3.3.3 Light, Not Electrons}{section.3.3}
\BOOKMARK [2][-]{subsection.3.3.4}{3.3.4 Special-Purpose Accelerators}{section.3.3}
\BOOKMARK [2][-]{subsection.3.3.5}{3.3.5 Existing Parallel Software}{section.3.3}
\BOOKMARK [1][-]{section.3.4}{3.4 Software Design Implications}{chapter.3}
\BOOKMARK [0][-]{chapter.4}{4 Tools of the Trade}{}
\BOOKMARK [1][-]{section.4.1}{4.1 Scripting Languages}{chapter.4}
\BOOKMARK [1][-]{section.4.2}{4.2 POSIX Multiprocessing}{chapter.4}
\BOOKMARK [2][-]{subsection.4.2.1}{4.2.1 POSIX Process Creation and Destruction}{section.4.2}
\BOOKMARK [2][-]{subsection.4.2.2}{4.2.2 POSIX Thread Creation and Destruction}{section.4.2}
\BOOKMARK [2][-]{subsection.4.2.3}{4.2.3 POSIX Locking}{section.4.2}
\BOOKMARK [2][-]{subsection.4.2.4}{4.2.4 POSIX Reader-Writer Locking}{section.4.2}
\BOOKMARK [1][-]{section.4.3}{4.3 Atomic Operations}{chapter.4}
\BOOKMARK [1][-]{section.4.4}{4.4 Linux-Kernel Equivalents to POSIX Operations}{chapter.4}
\BOOKMARK [1][-]{section.4.5}{4.5 The Right Tool for the Job: How to Choose?}{chapter.4}
\BOOKMARK [0][-]{chapter.5}{5 Counting}{}
\BOOKMARK [1][-]{section.5.1}{5.1 Why Isn't Concurrent Counting Trivial?}{chapter.5}
\BOOKMARK [1][-]{section.5.2}{5.2 Statistical Counters}{chapter.5}
\BOOKMARK [2][-]{subsection.5.2.1}{5.2.1 Design}{section.5.2}
\BOOKMARK [2][-]{subsection.5.2.2}{5.2.2 Array-Based Implementation}{section.5.2}
\BOOKMARK [2][-]{subsection.5.2.3}{5.2.3 Eventually Consistent Implementation}{section.5.2}
\BOOKMARK [2][-]{subsection.5.2.4}{5.2.4 Per-Thread-Variable-Based Implementation}{section.5.2}
\BOOKMARK [2][-]{subsection.5.2.5}{5.2.5 Discussion}{section.5.2}
\BOOKMARK [1][-]{section.5.3}{5.3 Approximate Limit Counters}{chapter.5}
\BOOKMARK [2][-]{subsection.5.3.1}{5.3.1 Design}{section.5.3}
\BOOKMARK [2][-]{subsection.5.3.2}{5.3.2 Simple Limit Counter Implementation}{section.5.3}
\BOOKMARK [2][-]{subsection.5.3.3}{5.3.3 Simple Limit Counter Discussion}{section.5.3}
\BOOKMARK [2][-]{subsection.5.3.4}{5.3.4 Approximate Limit Counter Implementation}{section.5.3}
\BOOKMARK [2][-]{subsection.5.3.5}{5.3.5 Approximate Limit Counter Discussion}{section.5.3}
\BOOKMARK [1][-]{section.5.4}{5.4 Exact Limit Counters}{chapter.5}
\BOOKMARK [2][-]{subsection.5.4.1}{5.4.1 Atomic Limit Counter Implementation}{section.5.4}
\BOOKMARK [2][-]{subsection.5.4.2}{5.4.2 Atomic Limit Counter Discussion}{section.5.4}
\BOOKMARK [2][-]{subsection.5.4.3}{5.4.3 Signal-Theft Limit Counter Design}{section.5.4}
\BOOKMARK [2][-]{subsection.5.4.4}{5.4.4 Signal-Theft Limit Counter Implementation}{section.5.4}
\BOOKMARK [2][-]{subsection.5.4.5}{5.4.5 Signal-Theft Limit Counter Discussion}{section.5.4}
\BOOKMARK [1][-]{section.5.5}{5.5 Applying Specialized Parallel Counters}{chapter.5}
\BOOKMARK [1][-]{section.5.6}{5.6 Parallel Counting Discussion}{chapter.5}
\BOOKMARK [0][-]{chapter.6}{6 Partitioning and Synchronization Design}{}
\BOOKMARK [1][-]{section.6.1}{6.1 Partitioning Exercises}{chapter.6}
\BOOKMARK [2][-]{subsection.6.1.1}{6.1.1 Dining Philosophers Problem}{section.6.1}
\BOOKMARK [2][-]{subsection.6.1.2}{6.1.2 Double-Ended Queue}{section.6.1}
\BOOKMARK [2][-]{subsection.6.1.3}{6.1.3 Partitioning Example Discussion}{section.6.1}
\BOOKMARK [1][-]{section.6.2}{6.2 Design Criteria}{chapter.6}
\BOOKMARK [1][-]{section.6.3}{6.3 Synchronization Granularity}{chapter.6}
\BOOKMARK [2][-]{subsection.6.3.1}{6.3.1 Sequential Program}{section.6.3}
\BOOKMARK [2][-]{subsection.6.3.2}{6.3.2 Code Locking}{section.6.3}
\BOOKMARK [2][-]{subsection.6.3.3}{6.3.3 Data Locking}{section.6.3}
\BOOKMARK [2][-]{subsection.6.3.4}{6.3.4 Data Ownership}{section.6.3}
\BOOKMARK [2][-]{subsection.6.3.5}{6.3.5 Locking Granularity and Performance}{section.6.3}
\BOOKMARK [1][-]{section.6.4}{6.4 Parallel Fastpath}{chapter.6}
\BOOKMARK [2][-]{subsection.6.4.1}{6.4.1 Reader/Writer Locking}{section.6.4}
\BOOKMARK [2][-]{subsection.6.4.2}{6.4.2 Hierarchical Locking}{section.6.4}
\BOOKMARK [2][-]{subsection.6.4.3}{6.4.3 Resource Allocator Caches}{section.6.4}
\BOOKMARK [1][-]{section.6.5}{6.5 Beyond Partitioning}{chapter.6}
\BOOKMARK [2][-]{subsection.6.5.1}{6.5.1 Work-Queue Parallel Maze Solver}{section.6.5}
\BOOKMARK [2][-]{subsection.6.5.2}{6.5.2 Alternative Parallel Maze Solver}{section.6.5}
\BOOKMARK [2][-]{subsection.6.5.3}{6.5.3 Performance Comparison I}{section.6.5}
\BOOKMARK [2][-]{subsection.6.5.4}{6.5.4 Alternative Sequential Maze Solver}{section.6.5}
\BOOKMARK [2][-]{subsection.6.5.5}{6.5.5 Performance Comparison II}{section.6.5}
\BOOKMARK [2][-]{subsection.6.5.6}{6.5.6 Future Directions and Conclusions}{section.6.5}
\BOOKMARK [1][-]{section.6.6}{6.6 Partitioning, Parallelism, and Optimization}{chapter.6}
\BOOKMARK [0][-]{chapter.7}{7 Locking}{}
\BOOKMARK [1][-]{section.7.1}{7.1 Staying Alive}{chapter.7}
\BOOKMARK [2][-]{subsection.7.1.1}{7.1.1 Deadlock}{section.7.1}
\BOOKMARK [2][-]{subsection.7.1.2}{7.1.2 Livelock and Starvation}{section.7.1}
\BOOKMARK [2][-]{subsection.7.1.3}{7.1.3 Unfairness}{section.7.1}
\BOOKMARK [2][-]{subsection.7.1.4}{7.1.4 Inefficiency}{section.7.1}
\BOOKMARK [1][-]{section.7.2}{7.2 Types of Locks}{chapter.7}
\BOOKMARK [2][-]{subsection.7.2.1}{7.2.1 Exclusive Locks}{section.7.2}
\BOOKMARK [2][-]{subsection.7.2.2}{7.2.2 Reader-Writer Locks}{section.7.2}
\BOOKMARK [2][-]{subsection.7.2.3}{7.2.3 Beyond Reader-Writer Locks}{section.7.2}
\BOOKMARK [2][-]{subsection.7.2.4}{7.2.4 Scoped Locking}{section.7.2}
\BOOKMARK [1][-]{section.7.3}{7.3 Locking Implementation Issues}{chapter.7}
\BOOKMARK [2][-]{subsection.7.3.1}{7.3.1 Sample Exclusive-Locking Implementation Based on Atomic Exchange}{section.7.3}
\BOOKMARK [2][-]{subsection.7.3.2}{7.3.2 Other Exclusive-Locking Implementations}{section.7.3}
\BOOKMARK [1][-]{section.7.4}{7.4 Lock-Based Existence Guarantees}{chapter.7}
\BOOKMARK [1][-]{section.7.5}{7.5 Locking: Hero or Villain?}{chapter.7}
\BOOKMARK [2][-]{subsection.7.5.1}{7.5.1 Locking For Applications: Hero!}{section.7.5}
\BOOKMARK [2][-]{subsection.7.5.2}{7.5.2 Locking For Parallel Libraries: Just Another Tool}{section.7.5}
\BOOKMARK [2][-]{subsection.7.5.3}{7.5.3 Locking For Parallelizing Sequential Libraries: Villain!}{section.7.5}
\BOOKMARK [1][-]{section.7.6}{7.6 Summary}{chapter.7}
\BOOKMARK [0][-]{chapter.8}{8 Data Ownership}{}
\BOOKMARK [1][-]{section.8.1}{8.1 Multiple Processes}{chapter.8}
\BOOKMARK [1][-]{section.8.2}{8.2 Partial Data Ownership and pthreads}{chapter.8}
\BOOKMARK [1][-]{section.8.3}{8.3 Function Shipping}{chapter.8}
\BOOKMARK [1][-]{section.8.4}{8.4 Designated Thread}{chapter.8}
\BOOKMARK [1][-]{section.8.5}{8.5 Privatization}{chapter.8}
\BOOKMARK [1][-]{section.8.6}{8.6 Other Uses of Data Ownership}{chapter.8}
\BOOKMARK [0][-]{chapter.9}{9 Deferred Processing}{}
\BOOKMARK [1][-]{section.9.1}{9.1 Reference Counting}{chapter.9}
\BOOKMARK [2][-]{subsection.9.1.1}{9.1.1 Implementation of Reference-Counting Categories}{section.9.1}
\BOOKMARK [2][-]{subsection.9.1.2}{9.1.2 Hazard Pointers}{section.9.1}
\BOOKMARK [2][-]{subsection.9.1.3}{9.1.3 Linux Primitives Supporting Reference Counting}{section.9.1}
\BOOKMARK [2][-]{subsection.9.1.4}{9.1.4 Counter Optimizations}{section.9.1}
\BOOKMARK [1][-]{section.9.2}{9.2 Sequence Locks}{chapter.9}
\BOOKMARK [1][-]{section.9.3}{9.3 Read-Copy Update \(RCU\)}{chapter.9}
\BOOKMARK [2][-]{subsection.9.3.1}{9.3.1 Introduction to RCU}{section.9.3}
\BOOKMARK [2][-]{subsection.9.3.2}{9.3.2 RCU Fundamentals}{section.9.3}
\BOOKMARK [2][-]{subsection.9.3.3}{9.3.3 RCU Usage}{section.9.3}
\BOOKMARK [2][-]{subsection.9.3.4}{9.3.4 RCU Linux-Kernel API}{section.9.3}
\BOOKMARK [2][-]{subsection.9.3.5}{9.3.5 ``Toy'' RCU Implementations}{section.9.3}
\BOOKMARK [2][-]{subsection.9.3.6}{9.3.6 RCU Exercises}{section.9.3}
\BOOKMARK [1][-]{section.9.4}{9.4 Which to Choose?}{chapter.9}
\BOOKMARK [1][-]{section.9.5}{9.5 What About Updates?}{chapter.9}
\BOOKMARK [0][-]{chapter.10}{10 Data Structures}{}
\BOOKMARK [1][-]{section.10.1}{10.1 Motivating Application}{chapter.10}
\BOOKMARK [1][-]{section.10.2}{10.2 Partitionable Data Structures}{chapter.10}
\BOOKMARK [2][-]{subsection.10.2.1}{10.2.1 Hash-Table Design}{section.10.2}
\BOOKMARK [2][-]{subsection.10.2.2}{10.2.2 Hash-Table Implementation}{section.10.2}
\BOOKMARK [2][-]{subsection.10.2.3}{10.2.3 Hash-Table Performance}{section.10.2}
\BOOKMARK [1][-]{section.10.3}{10.3 Read-Mostly Data Structures}{chapter.10}
\BOOKMARK [2][-]{subsection.10.3.1}{10.3.1 RCU-Protected Hash Table Implementation}{section.10.3}
\BOOKMARK [2][-]{subsection.10.3.2}{10.3.2 RCU-Protected Hash Table Performance}{section.10.3}
\BOOKMARK [2][-]{subsection.10.3.3}{10.3.3 RCU-Protected Hash Table Discussion}{section.10.3}
\BOOKMARK [1][-]{section.10.4}{10.4 Non-Partitionable Data Structures}{chapter.10}
\BOOKMARK [2][-]{subsection.10.4.1}{10.4.1 Resizable Hash Table Design}{section.10.4}
\BOOKMARK [2][-]{subsection.10.4.2}{10.4.2 Resizable Hash Table Implementation}{section.10.4}
\BOOKMARK [2][-]{subsection.10.4.3}{10.4.3 Resizable Hash Table Discussion}{section.10.4}
\BOOKMARK [2][-]{subsection.10.4.4}{10.4.4 Other Resizable Hash Tables}{section.10.4}
\BOOKMARK [1][-]{section.10.5}{10.5 Other Data Structures}{chapter.10}
\BOOKMARK [1][-]{section.10.6}{10.6 Micro-Optimization}{chapter.10}
\BOOKMARK [2][-]{subsection.10.6.1}{10.6.1 Specialization}{section.10.6}
\BOOKMARK [2][-]{subsection.10.6.2}{10.6.2 Bits and Bytes}{section.10.6}
\BOOKMARK [2][-]{subsection.10.6.3}{10.6.3 Hardware Considerations}{section.10.6}
\BOOKMARK [1][-]{section.10.7}{10.7 Summary}{chapter.10}
\BOOKMARK [0][-]{chapter.11}{11 Validation}{}
\BOOKMARK [1][-]{section.11.1}{11.1 Introduction}{chapter.11}
\BOOKMARK [2][-]{subsection.11.1.1}{11.1.1 Where Do Bugs Come From?}{section.11.1}
\BOOKMARK [2][-]{subsection.11.1.2}{11.1.2 Required Mindset}{section.11.1}
\BOOKMARK [2][-]{subsection.11.1.3}{11.1.3 When Should Validation Start?}{section.11.1}
\BOOKMARK [2][-]{subsection.11.1.4}{11.1.4 The Open Source Way}{section.11.1}
\BOOKMARK [1][-]{section.11.2}{11.2 Tracing}{chapter.11}
\BOOKMARK [1][-]{section.11.3}{11.3 Assertions}{chapter.11}
\BOOKMARK [1][-]{section.11.4}{11.4 Static Analysis}{chapter.11}
\BOOKMARK [1][-]{section.11.5}{11.5 Code Review}{chapter.11}
\BOOKMARK [2][-]{subsection.11.5.1}{11.5.1 Inspection}{section.11.5}
\BOOKMARK [2][-]{subsection.11.5.2}{11.5.2 Walkthroughs}{section.11.5}
\BOOKMARK [2][-]{subsection.11.5.3}{11.5.3 Self-Inspection}{section.11.5}
\BOOKMARK [1][-]{section.11.6}{11.6 Probability and Heisenbugs}{chapter.11}
\BOOKMARK [2][-]{subsection.11.6.1}{11.6.1 Statistics for Discrete Testing}{section.11.6}
\BOOKMARK [2][-]{subsection.11.6.2}{11.6.2 Abusing Statistics for Discrete Testing}{section.11.6}
\BOOKMARK [2][-]{subsection.11.6.3}{11.6.3 Statistics for Continuous Testing}{section.11.6}
\BOOKMARK [2][-]{subsection.11.6.4}{11.6.4 Hunting Heisenbugs}{section.11.6}
\BOOKMARK [1][-]{section.11.7}{11.7 Performance Estimation}{chapter.11}
\BOOKMARK [2][-]{subsection.11.7.1}{11.7.1 Benchmarking}{section.11.7}
\BOOKMARK [2][-]{subsection.11.7.2}{11.7.2 Profiling}{section.11.7}
\BOOKMARK [2][-]{subsection.11.7.3}{11.7.3 Differential Profiling}{section.11.7}
\BOOKMARK [2][-]{subsection.11.7.4}{11.7.4 Microbenchmarking}{section.11.7}
\BOOKMARK [2][-]{subsection.11.7.5}{11.7.5 Isolation}{section.11.7}
\BOOKMARK [2][-]{subsection.11.7.6}{11.7.6 Detecting Interference}{section.11.7}
\BOOKMARK [1][-]{section.11.8}{11.8 Summary}{chapter.11}
\BOOKMARK [0][-]{chapter.12}{12 Formal Verification}{}
\BOOKMARK [1][-]{section.12.1}{12.1 What are Promela and Spin?}{chapter.12}
\BOOKMARK [1][-]{section.12.2}{12.2 Promela Example: Non-Atomic Increment}{chapter.12}
\BOOKMARK [1][-]{section.12.3}{12.3 Promela Example: Atomic Increment}{chapter.12}
\BOOKMARK [2][-]{subsection.12.3.1}{12.3.1 Combinatorial Explosion}{section.12.3}
\BOOKMARK [1][-]{section.12.4}{12.4 How to Use Promela}{chapter.12}
\BOOKMARK [2][-]{subsection.12.4.1}{12.4.1 Promela Peculiarities}{section.12.4}
\BOOKMARK [2][-]{subsection.12.4.2}{12.4.2 Promela Coding Tricks}{section.12.4}
\BOOKMARK [1][-]{section.12.5}{12.5 Promela Example: Locking}{chapter.12}
\BOOKMARK [1][-]{section.12.6}{12.6 Promela Example: QRCU}{chapter.12}
\BOOKMARK [2][-]{subsection.12.6.1}{12.6.1 Running the QRCU Example}{section.12.6}
\BOOKMARK [2][-]{subsection.12.6.2}{12.6.2 How Many Readers and Updaters Are Really Needed?}{section.12.6}
\BOOKMARK [2][-]{subsection.12.6.3}{12.6.3 Alternative Approach: Proof of Correctness}{section.12.6}
\BOOKMARK [2][-]{subsection.12.6.4}{12.6.4 Alternative Approach: More Capable Tools}{section.12.6}
\BOOKMARK [2][-]{subsection.12.6.5}{12.6.5 Alternative Approach: Divide and Conquer}{section.12.6}
\BOOKMARK [1][-]{section.12.7}{12.7 Promela Parable: dynticks and Preemptible RCU}{chapter.12}
\BOOKMARK [2][-]{subsection.12.7.1}{12.7.1 Introduction to Preemptible RCU and dynticks}{section.12.7}
\BOOKMARK [2][-]{subsection.12.7.2}{12.7.2 Validating Preemptible RCU and dynticks}{section.12.7}
\BOOKMARK [2][-]{subsection.12.7.3}{12.7.3 Lessons \(Re\)Learned}{section.12.7}
\BOOKMARK [1][-]{section.12.8}{12.8 Simplicity Avoids Formal Verification}{chapter.12}
\BOOKMARK [2][-]{subsection.12.8.1}{12.8.1 State Variables for Simplified Dynticks Interface}{section.12.8}
\BOOKMARK [2][-]{subsection.12.8.2}{12.8.2 Entering and Leaving Dynticks-Idle Mode}{section.12.8}
\BOOKMARK [2][-]{subsection.12.8.3}{12.8.3 NMIs From Dynticks-Idle Mode}{section.12.8}
\BOOKMARK [2][-]{subsection.12.8.4}{12.8.4 Interrupts From Dynticks-Idle Mode}{section.12.8}
\BOOKMARK [2][-]{subsection.12.8.5}{12.8.5 Checking For Dynticks Quiescent States}{section.12.8}
\BOOKMARK [2][-]{subsection.12.8.6}{12.8.6 Discussion}{section.12.8}
\BOOKMARK [1][-]{section.12.9}{12.9 Formal Verification and Memory Ordering}{chapter.12}
\BOOKMARK [2][-]{subsection.12.9.1}{12.9.1 Anatomy of a Litmus Test}{section.12.9}
\BOOKMARK [2][-]{subsection.12.9.2}{12.9.2 What Does This Litmus Test Mean?}{section.12.9}
\BOOKMARK [2][-]{subsection.12.9.3}{12.9.3 Running a Litmus Test}{section.12.9}
\BOOKMARK [2][-]{subsection.12.9.4}{12.9.4 PPCMEM Discussion}{section.12.9}
\BOOKMARK [1][-]{section.12.10}{12.10 Summary}{chapter.12}
\BOOKMARK [0][-]{chapter.13}{13 Putting It All Together}{}
\BOOKMARK [1][-]{section.13.1}{13.1 Counter Conundrums}{chapter.13}
\BOOKMARK [2][-]{subsection.13.1.1}{13.1.1 Counting Updates}{section.13.1}
\BOOKMARK [2][-]{subsection.13.1.2}{13.1.2 Counting Lookups}{section.13.1}
\BOOKMARK [1][-]{section.13.2}{13.2 RCU Rescues}{chapter.13}
\BOOKMARK [2][-]{subsection.13.2.1}{13.2.1 RCU and Per-Thread-Variable-Based Statistical Counters}{section.13.2}
\BOOKMARK [2][-]{subsection.13.2.2}{13.2.2 RCU and Counters for Removable I/O Devices}{section.13.2}
\BOOKMARK [2][-]{subsection.13.2.3}{13.2.3 Array and Length}{section.13.2}
\BOOKMARK [2][-]{subsection.13.2.4}{13.2.4 Correlated Fields}{section.13.2}
\BOOKMARK [1][-]{section.13.3}{13.3 Hashing Hassles}{chapter.13}
\BOOKMARK [2][-]{subsection.13.3.1}{13.3.1 Correlated Data Elements}{section.13.3}
\BOOKMARK [2][-]{subsection.13.3.2}{13.3.2 Update-Friendly Hash-Table Traversal}{section.13.3}
\BOOKMARK [0][-]{chapter.14}{14 Advanced Synchronization}{}
\BOOKMARK [1][-]{section.14.1}{14.1 Avoiding Locks}{chapter.14}
\BOOKMARK [1][-]{section.14.2}{14.2 Memory Barriers}{chapter.14}
\BOOKMARK [2][-]{subsection.14.2.1}{14.2.1 Memory Ordering and Memory Barriers}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.2}{14.2.2 If B Follows A, and C Follows B, Why Doesn't C Follow A?}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.3}{14.2.3 Variables Can Have More Than One Value}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.4}{14.2.4 What Can You Trust?}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.5}{14.2.5 Review of Locking Implementations}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.6}{14.2.6 A Few Simple Rules}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.7}{14.2.7 Abstract Memory Access Model}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.8}{14.2.8 Device Operations}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.9}{14.2.9 Guarantees}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.10}{14.2.10 What Are Memory Barriers?}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.11}{14.2.11 Locking Constraints}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.12}{14.2.12 Memory-Barrier Examples}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.13}{14.2.13 The Effects of the CPU Cache}{section.14.2}
\BOOKMARK [2][-]{subsection.14.2.14}{14.2.14 Where Are Memory Barriers Needed?}{section.14.2}
\BOOKMARK [1][-]{section.14.3}{14.3 Non-Blocking Synchronization}{chapter.14}
\BOOKMARK [2][-]{subsection.14.3.1}{14.3.1 Simple NBS}{section.14.3}
\BOOKMARK [2][-]{subsection.14.3.2}{14.3.2 NBS Discussion}{section.14.3}
\BOOKMARK [0][-]{chapter.15}{15 Ease of Use}{}
\BOOKMARK [1][-]{section.15.1}{15.1 What is Easy?}{chapter.15}
\BOOKMARK [1][-]{section.15.2}{15.2 Rusty Scale for API Design}{chapter.15}
\BOOKMARK [1][-]{section.15.3}{15.3 Shaving the Mandelbrot Set}{chapter.15}
\BOOKMARK [0][-]{chapter.16}{16 Conflicting Visions of the Future}{}
\BOOKMARK [1][-]{section.16.1}{16.1 The Future of CPU Technology Ain't What it Used to Be}{chapter.16}
\BOOKMARK [2][-]{subsection.16.1.1}{16.1.1 Uniprocessor \334ber Alles}{section.16.1}
\BOOKMARK [2][-]{subsection.16.1.2}{16.1.2 Multithreaded Mania}{section.16.1}
\BOOKMARK [2][-]{subsection.16.1.3}{16.1.3 More of the Same}{section.16.1}
\BOOKMARK [2][-]{subsection.16.1.4}{16.1.4 Crash Dummies Slamming into the Memory Wall}{section.16.1}
\BOOKMARK [1][-]{section.16.2}{16.2 Transactional Memory}{chapter.16}
\BOOKMARK [2][-]{subsection.16.2.1}{16.2.1 Outside World}{section.16.2}
\BOOKMARK [2][-]{subsection.16.2.2}{16.2.2 Process Modification}{section.16.2}
\BOOKMARK [2][-]{subsection.16.2.3}{16.2.3 Synchronization}{section.16.2}
\BOOKMARK [2][-]{subsection.16.2.4}{16.2.4 Discussion}{section.16.2}
\BOOKMARK [1][-]{section.16.3}{16.3 Hardware Transactional Memory}{chapter.16}
\BOOKMARK [2][-]{subsection.16.3.1}{16.3.1 HTM Benefits WRT to Locking}{section.16.3}
\BOOKMARK [2][-]{subsection.16.3.2}{16.3.2 HTM Weaknesses WRT Locking}{section.16.3}
\BOOKMARK [2][-]{subsection.16.3.3}{16.3.3 HTM Weaknesses WRT to Locking When Augmented}{section.16.3}
\BOOKMARK [2][-]{subsection.16.3.4}{16.3.4 Where Does HTM Best Fit In?}{section.16.3}
\BOOKMARK [2][-]{subsection.16.3.5}{16.3.5 Potential Game Changers}{section.16.3}
\BOOKMARK [2][-]{subsection.16.3.6}{16.3.6 Conclusions}{section.16.3}
\BOOKMARK [1][-]{section.16.4}{16.4 Functional Programming for Parallelism}{chapter.16}
\BOOKMARK [0][-]{appendix.A}{A Important Questions}{}
\BOOKMARK [1][-]{section.A.1}{A.1 What Does ``After'' Mean?}{appendix.A}
\BOOKMARK [1][-]{section.A.2}{A.2 What Time Is It?}{appendix.A}
\BOOKMARK [0][-]{appendix.B}{B Synchronization Primitives}{}
\BOOKMARK [1][-]{section.B.1}{B.1 Organization and Initialization}{appendix.B}
\BOOKMARK [2][-]{subsection.B.1.1}{B.1.1 smp\137init\(\):}{section.B.1}
\BOOKMARK [1][-]{section.B.2}{B.2 Thread Creation, Destruction, and Control}{appendix.B}
\BOOKMARK [2][-]{subsection.B.2.1}{B.2.1 create\137thread\(\)}{section.B.2}
\BOOKMARK [2][-]{subsection.B.2.2}{B.2.2 smp\137thread\137id\(\)}{section.B.2}
\BOOKMARK [2][-]{subsection.B.2.3}{B.2.3 for\137each\137thread\(\)}{section.B.2}
\BOOKMARK [2][-]{subsection.B.2.4}{B.2.4 for\137each\137running\137thread\(\)}{section.B.2}
\BOOKMARK [2][-]{subsection.B.2.5}{B.2.5 wait\137thread\(\)}{section.B.2}
\BOOKMARK [2][-]{subsection.B.2.6}{B.2.6 wait\137all\137threads\(\)}{section.B.2}
\BOOKMARK [2][-]{subsection.B.2.7}{B.2.7 Example Usage}{section.B.2}
\BOOKMARK [1][-]{section.B.3}{B.3 Locking}{appendix.B}
\BOOKMARK [2][-]{subsection.B.3.1}{B.3.1 spin\137lock\137init\(\)}{section.B.3}
\BOOKMARK [2][-]{subsection.B.3.2}{B.3.2 spin\137lock\(\)}{section.B.3}
\BOOKMARK [2][-]{subsection.B.3.3}{B.3.3 spin\137trylock\(\)}{section.B.3}
\BOOKMARK [2][-]{subsection.B.3.4}{B.3.4 spin\137unlock\(\)}{section.B.3}
\BOOKMARK [2][-]{subsection.B.3.5}{B.3.5 Example Usage}{section.B.3}
\BOOKMARK [1][-]{section.B.4}{B.4 Per-Thread Variables}{appendix.B}
\BOOKMARK [2][-]{subsection.B.4.1}{B.4.1 DEFINE\137PER\137THREAD\(\)}{section.B.4}
\BOOKMARK [2][-]{subsection.B.4.2}{B.4.2 DECLARE\137PER\137THREAD\(\)}{section.B.4}
\BOOKMARK [2][-]{subsection.B.4.3}{B.4.3 per\137thread\(\)}{section.B.4}
\BOOKMARK [2][-]{subsection.B.4.4}{B.4.4 \137\137get\137thread\137var\(\)}{section.B.4}
\BOOKMARK [2][-]{subsection.B.4.5}{B.4.5 init\137per\137thread\(\)}{section.B.4}
\BOOKMARK [2][-]{subsection.B.4.6}{B.4.6 Usage Example}{section.B.4}
\BOOKMARK [1][-]{section.B.5}{B.5 Performance}{appendix.B}
\BOOKMARK [0][-]{appendix.C}{C Why Memory Barriers?}{}
\BOOKMARK [1][-]{section.C.1}{C.1 Cache Structure}{appendix.C}
\BOOKMARK [1][-]{section.C.2}{C.2 Cache-Coherence Protocols}{appendix.C}
\BOOKMARK [2][-]{subsection.C.2.1}{C.2.1 MESI States}{section.C.2}
\BOOKMARK [2][-]{subsection.C.2.2}{C.2.2 MESI Protocol Messages}{section.C.2}
\BOOKMARK [2][-]{subsection.C.2.3}{C.2.3 MESI State Diagram}{section.C.2}
\BOOKMARK [2][-]{subsection.C.2.4}{C.2.4 MESI Protocol Example}{section.C.2}
\BOOKMARK [1][-]{section.C.3}{C.3 Stores Result in Unnecessary Stalls}{appendix.C}
\BOOKMARK [2][-]{subsection.C.3.1}{C.3.1 Store Buffers}{section.C.3}
\BOOKMARK [2][-]{subsection.C.3.2}{C.3.2 Store Forwarding}{section.C.3}
\BOOKMARK [2][-]{subsection.C.3.3}{C.3.3 Store Buffers and Memory Barriers}{section.C.3}
\BOOKMARK [1][-]{section.C.4}{C.4 Store Sequences Result in Unnecessary Stalls}{appendix.C}
\BOOKMARK [2][-]{subsection.C.4.1}{C.4.1 Invalidate Queues}{section.C.4}
\BOOKMARK [2][-]{subsection.C.4.2}{C.4.2 Invalidate Queues and Invalidate Acknowledge}{section.C.4}
\BOOKMARK [2][-]{subsection.C.4.3}{C.4.3 Invalidate Queues and Memory Barriers}{section.C.4}
\BOOKMARK [1][-]{section.C.5}{C.5 Read and Write Memory Barriers}{appendix.C}
\BOOKMARK [1][-]{section.C.6}{C.6 Example Memory-Barrier Sequences}{appendix.C}
\BOOKMARK [2][-]{subsection.C.6.1}{C.6.1 Ordering-Hostile Architecture}{section.C.6}
\BOOKMARK [2][-]{subsection.C.6.2}{C.6.2 Example 1}{section.C.6}
\BOOKMARK [2][-]{subsection.C.6.3}{C.6.3 Example 2}{section.C.6}
\BOOKMARK [2][-]{subsection.C.6.4}{C.6.4 Example 3}{section.C.6}
\BOOKMARK [1][-]{section.C.7}{C.7 Memory-Barrier Instructions For Specific CPUs}{appendix.C}
\BOOKMARK [2][-]{subsection.C.7.1}{C.7.1 Alpha}{section.C.7}
\BOOKMARK [2][-]{subsection.C.7.2}{C.7.2 AMD64}{section.C.7}
\BOOKMARK [2][-]{subsection.C.7.3}{C.7.3 ARMv7-A/R}{section.C.7}
\BOOKMARK [2][-]{subsection.C.7.4}{C.7.4 IA64}{section.C.7}
\BOOKMARK [2][-]{subsection.C.7.5}{C.7.5 PA-RISC}{section.C.7}
\BOOKMARK [2][-]{subsection.C.7.6}{C.7.6 POWER / PowerPC}{section.C.7}
\BOOKMARK [2][-]{subsection.C.7.7}{C.7.7 SPARC RMO, PSO, and TSO}{section.C.7}
\BOOKMARK [2][-]{subsection.C.7.8}{C.7.8 x86}{section.C.7}
\BOOKMARK [2][-]{subsection.C.7.9}{C.7.9 zSeries}{section.C.7}
\BOOKMARK [1][-]{section.C.8}{C.8 Are Memory Barriers Forever?}{appendix.C}
\BOOKMARK [1][-]{section.C.9}{C.9 Advice to Hardware Designers}{appendix.C}
\BOOKMARK [0][-]{appendix.D}{D Read-Copy Update Implementations}{}
\BOOKMARK [1][-]{section.D.1}{D.1 Sleepable RCU Implementation}{appendix.D}
\BOOKMARK [2][-]{subsection.D.1.1}{D.1.1 SRCU Implementation Strategy}{section.D.1}
\BOOKMARK [2][-]{subsection.D.1.2}{D.1.2 SRCU API and Usage}{section.D.1}
\BOOKMARK [2][-]{subsection.D.1.3}{D.1.3 Implementation}{section.D.1}
\BOOKMARK [2][-]{subsection.D.1.4}{D.1.4 SRCU Summary}{section.D.1}
\BOOKMARK [1][-]{section.D.2}{D.2 Hierarchical RCU Overview}{appendix.D}
\BOOKMARK [2][-]{subsection.D.2.1}{D.2.1 Review of RCU Fundamentals}{section.D.2}
\BOOKMARK [2][-]{subsection.D.2.2}{D.2.2 Brief Overview of Classic RCU Implementation}{section.D.2}
\BOOKMARK [2][-]{subsection.D.2.3}{D.2.3 RCU Desiderata}{section.D.2}
\BOOKMARK [2][-]{subsection.D.2.4}{D.2.4 Towards a More Scalable RCU Implementation}{section.D.2}
\BOOKMARK [2][-]{subsection.D.2.5}{D.2.5 Towards a Greener RCU Implementation}{section.D.2}
\BOOKMARK [2][-]{subsection.D.2.6}{D.2.6 State Machine}{section.D.2}
\BOOKMARK [2][-]{subsection.D.2.7}{D.2.7 Use Cases}{section.D.2}
\BOOKMARK [2][-]{subsection.D.2.8}{D.2.8 Testing}{section.D.2}
\BOOKMARK [2][-]{subsection.D.2.9}{D.2.9 Conclusion}{section.D.2}
\BOOKMARK [1][-]{section.D.3}{D.3 Hierarchical RCU Code Walkthrough}{appendix.D}
\BOOKMARK [2][-]{subsection.D.3.1}{D.3.1 Data Structures and Kernel Parameters}{section.D.3}
\BOOKMARK [2][-]{subsection.D.3.2}{D.3.2 External Interfaces}{section.D.3}
\BOOKMARK [2][-]{subsection.D.3.3}{D.3.3 Initialization}{section.D.3}
\BOOKMARK [2][-]{subsection.D.3.4}{D.3.4 CPU Hotplug}{section.D.3}
\BOOKMARK [2][-]{subsection.D.3.5}{D.3.5 Miscellaneous Functions}{section.D.3}
\BOOKMARK [2][-]{subsection.D.3.6}{D.3.6 Grace-Period-Detection Functions}{section.D.3}
\BOOKMARK [2][-]{subsection.D.3.7}{D.3.7 Dyntick-Idle Functions}{section.D.3}
\BOOKMARK [2][-]{subsection.D.3.8}{D.3.8 Forcing Quiescent States}{section.D.3}
\BOOKMARK [2][-]{subsection.D.3.9}{D.3.9 CPU-Stall Detection}{section.D.3}
\BOOKMARK [2][-]{subsection.D.3.10}{D.3.10 Possible Flaws and Changes}{section.D.3}
\BOOKMARK [1][-]{section.D.4}{D.4 Preemptible RCU}{appendix.D}
\BOOKMARK [2][-]{subsection.D.4.1}{D.4.1 Conceptual RCU}{section.D.4}
\BOOKMARK [2][-]{subsection.D.4.2}{D.4.2 Overview of Preemptible RCU Algorithm}{section.D.4}
\BOOKMARK [2][-]{subsection.D.4.3}{D.4.3 Validation of Preemptible RCU}{section.D.4}
\BOOKMARK [0][-]{appendix.E}{E Read-Copy Update in Linux}{}
\BOOKMARK [1][-]{section.E.1}{E.1 RCU Usage Within Linux}{appendix.E}
\BOOKMARK [1][-]{section.E.2}{E.2 RCU Evolution}{appendix.E}
\BOOKMARK [2][-]{subsection.E.2.1}{E.2.1 2.6.27 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.2}{E.2.2 2.6.28 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.3}{E.2.3 2.6.29 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.4}{E.2.4 2.6.31 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.5}{E.2.5 2.6.32 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.6}{E.2.6 2.6.33 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.7}{E.2.7 2.6.34 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.8}{E.2.8 2.6.35 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.9}{E.2.9 2.6.36 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.10}{E.2.10 2.6.37 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.11}{E.2.11 2.6.38 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.12}{E.2.12 2.6.39 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.13}{E.2.13 3.0 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.14}{E.2.14 3.1 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.15}{E.2.15 3.2 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.16}{E.2.16 3.3 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.17}{E.2.17 3.4 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.18}{E.2.18 3.5 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.19}{E.2.19 3.6 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.20}{E.2.20 3.7 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.21}{E.2.21 3.8 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.22}{E.2.22 3.9 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.23}{E.2.23 3.10 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.24}{E.2.24 3.11 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.25}{E.2.25 3.12 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.26}{E.2.26 3.13 Linux Kernel}{section.E.2}
\BOOKMARK [2][-]{subsection.E.2.27}{E.2.27 3.14 Linux Kernel}{section.E.2}
\BOOKMARK [0][-]{appendix.F}{F Answers to Quick Quizzes}{}
\BOOKMARK [1][-]{section.F.1}{F.1 How To Use This Book}{appendix.F}
\BOOKMARK [1][-]{section.F.2}{F.2 Introduction}{appendix.F}
\BOOKMARK [1][-]{section.F.3}{F.3 Hardware and its Habits}{appendix.F}
\BOOKMARK [1][-]{section.F.4}{F.4 Tools of the Trade}{appendix.F}
\BOOKMARK [1][-]{section.F.5}{F.5 Counting}{appendix.F}
\BOOKMARK [1][-]{section.F.6}{F.6 Partitioning and Synchronization Design}{appendix.F}
\BOOKMARK [1][-]{section.F.7}{F.7 Locking}{appendix.F}
\BOOKMARK [1][-]{section.F.8}{F.8 Data Ownership}{appendix.F}
\BOOKMARK [1][-]{section.F.9}{F.9 Deferred Processing}{appendix.F}
\BOOKMARK [1][-]{section.F.10}{F.10 Data Structures}{appendix.F}
\BOOKMARK [1][-]{section.F.11}{F.11 Validation}{appendix.F}
\BOOKMARK [1][-]{section.F.12}{F.12 Formal Verification}{appendix.F}
\BOOKMARK [1][-]{section.F.13}{F.13 Putting It All Together}{appendix.F}
\BOOKMARK [1][-]{section.F.14}{F.14 Advanced Synchronization}{appendix.F}
\BOOKMARK [1][-]{section.F.15}{F.15 Ease of Use}{appendix.F}
\BOOKMARK [1][-]{section.F.16}{F.16 Conflicting Visions of the Future}{appendix.F}
\BOOKMARK [1][-]{section.F.17}{F.17 Important Questions}{appendix.F}
\BOOKMARK [1][-]{section.F.18}{F.18 Synchronization Primitives}{appendix.F}
\BOOKMARK [1][-]{section.F.19}{F.19 Why Memory Barriers?}{appendix.F}
\BOOKMARK [1][-]{section.F.20}{F.20 Read-Copy Update Implementations}{appendix.F}
\BOOKMARK [0][-]{appendix.G}{G Glossary and Bibliography}{}
\BOOKMARK [0][-]{appendix.H}{H Credits}{}
\BOOKMARK [1][-]{section.H.1}{H.1 Authors}{appendix.H}
\BOOKMARK [1][-]{section.H.2}{H.2 Reviewers}{appendix.H}
\BOOKMARK [1][-]{section.H.3}{H.3 Machine Owners}{appendix.H}
\BOOKMARK [1][-]{section.H.4}{H.4 Original Publications}{appendix.H}
\BOOKMARK [1][-]{section.H.5}{H.5 Figure Credits}{appendix.H}
\BOOKMARK [1][-]{section.H.6}{H.6 Other Support}{appendix.H}
