% rt/rt.tex

\QuickQuizChapter{chp:Parallel Real-Time Computing}{Parallel Real-Time Computing}

An important emerging area in computing is that of parallel real-time
computing.
@@@ Roadmap @@@

\section{What is Real-Time Computing?}
\label{sec:rt:What is Real-Time Computing?}

One traditional way of classifying real-time computing is into the categories
of \emph{hard real time} and \emph{soft real time}, where the macho
hard real-time applications never ever miss their deadlines, but the
wimpy soft real-time applications might well miss their deadlines
frequently and often.

\subsection{Soft Real Time}
\label{sec:Soft Real Time}

It should be easy to see problems with this definition of soft real time.
For one thing, by this definition, \emph{any} piece of software could be
said to be a soft real-time application:
``My application computes million-point fourier transforms in half a
picosecond.''
``No way!!!
The clock cycle on this system is more the \emph{three hundred} picoseconds!''
``Ah, but it is a \emph{soft} real-time application!''
If the term ``soft real time'' is to be of any use whatesoever, some limits
are clearly required.

We might therefore say that a given soft real-time application must meet
its response-time requirements at least some fraction of the time, for
example, we might say that it must execute in less than 20 microseconds
99.9\% of the time.

This of course raises the question of what is to be done when the application
fails to meet its response-time requirements.
The answer of course varies with the application, but one possibility
is that the system being controlled has enough stability and inertia
that the occasional late control action is relatively harmless.
Another possibility is that the application has two ways of computing
the result, a fast but inaccurate method on the one hand and
a very accurate method with unpredictable compute time on the other.
For the latter possibility, one reasonable approach would be to start
both methods in parallel, and if the accurate method fails to finish
in time, kill it and use the answer from the fast but inaccurate method.
Of course, one candidate for the fast but inaccurate method is to take
no control action during the current time period, or, alternatively,
to take the same control action as was taken during the preceding time
period.

In short, it does not make sense to talk about soft real time without
some measure of exactly how soft it is to be.

\subsection{Hard Real Time}
\label{sec:Hard Real Time}

\begin{figure}[bt]
\begin{center}
\resizebox{3in}{!}{\includegraphics{cartoons/realtime-smash}}
\end{center}
\caption{Real-Time Response Guarantee, Meet Hammer}
\label{fig:rt:Real-Time Response Guarantee, Meet Hammer}
\end{figure}

In contrast, the definition of hard real time is quite definite.
After all, a given system either always meets its deadlines or it
doesn't.
Unfortunately, a strict application of this definition would mean that
there can never be any hard real time systems.
The reason for this is fancifully depicted in
Figure~\ref{fig:rt:Real-Time Response Guarantee, Meet Hammer}.
Of course, you could construct a more robust system, perhaps even
with added redundancy.
But I can always get a bigger hammer.

\begin{figure}[bt]
\begin{center}
\resizebox{3in}{!}{\includegraphics{cartoons/realtime-lifesupport-nobomb}}
\end{center}
\caption{Real-Time Response: Hardware Matters}
\label{fig:rt:Real-Time Response: Hardware Matters}
\end{figure}

Then again, perhaps it is unfair to blame the software for what is clearly
not just a hardware problem, but a bona fide big-iron hardware problem
at that.\footnote{
	Or, given modern hammers, a big-steel problem.}
This suggests that we define hard-real-time software as software that
will always meet its deadlines, but only in the absence of a hardware
failure.
Unfortunately, failure is not always an option, as fancifully depicted in
Figure~\ref{fig:rt:Real-Time Response: Hardware Matters}.
We simply cannot expect the poor gentleman depicted in that figure to be
reassured our saying ``Rest assured that if a missed deadline results
in your tragic death, it most certainly will not have been due to a
software problem!''
Hard real-time response is after all a property of the entire system, not
just of the software.

But if we cannot demand perfection, perhaps we can make do with
notification, similar to the soft real-time approach noted earlier.
Then if the Life-a-Tron in
Figure~\ref{fig:rt:Real-Time Response: Hardware Matters}
is about to miss its deadline,
it can alert the hospital staff.

\begin{figure*}[bt]
\begin{center}
\resizebox{6in}{!}{\rotatebox{90}{\includegraphics{cartoons/realtime-lazy-crop}}}
\end{center}
\caption{Real-Time Response: Notification Insufficient}
\label{fig:rt:Real-Time Response: Notification Insufficient}
\end{figure*}

Unfortunately, this approach has the trivial solution fancifully depicted in
Figure~\ref{fig:rt:Real-Time Response: Notification Insufficient}.
A system that always immediately issues a notification that it won't
be able to meet its deadline complies with the letter of the law,
but is completely useless.
There clearly must also be a requirement that the system meet its deadline
some fraction of the time, or perhaps that it be prohibited from missing
its deadlines on more than a certain number of consecutive operations.

We clearly cannot take a campaign-slogan approach to either hard or soft
real time.
The next section therefore takes a real-world approach.

\subsection{Real-World Real Time}
\label{sec:rt:Real-World Real Time}



\section{Who Needs Real-Time Computing?}
\label{sec:rt:Who Needs Real-Time Computing?}

\section{Who Needs Parallel Real-Time Computing?}
\label{sec:rt:Who Needs Parallel Real-Time Computing?}

\section{Implementing Parallel Real-Time Computing}
\label{sec:rt:Implementing Parallel Real-Time Computing}

